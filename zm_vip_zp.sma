/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <fakemeta>
#include <engine>
#include <fun>
#include <hamsandwich>
#include <zombieplague>
#include <zp50_gamemodes>
#include <zp50_class_dragon>
#include <zp50_class_nightcrawler>
#include <zp50_class_nemesis>
#include <zp50_class_predator>
#include <zp50_class_survivor>
#include <zp50_class_plasma>
#include <zp50_class_sniper>
#include <zp50_class_knifer>
#include <colorchat>

native zp_set_human_glow(id, bool:on);

////////// PLUGIN SETTINGS //////////
#define MODE 3
#define CHAT_PREFIX "[GC]"

// (Only if MODE 1 is turrned OFF. Otherwise set flags in vips.ini.) //
#define VIPACCES ADMIN_LEVEL_H
#define MJACCES ADMIN_LEVEL_H
////////// SETTINGS END //////////

// Flags
#define FLAG_A (1<<0)
#define FLAG_B (1<<1)
#define FLAG_C (1<<2)
#define FLAG_D (1<<3)
#define FLAG_E (1<<4)
#define FLAG_K (1<<10)

#define VERSION "1.7.2"

#if cellbits == 32
const OFFSET_CLIPAMMO = 51
#else
const OFFSET_CLIPAMMO = 65
#endif
const OFFSET_LINUX_WEAPONS = 4

const DMG_HEGRENADE = (1<<24)

#define set_flood(%1,%2)    (%1 |= (1<<(%2&31)))
#define clear_flood(%1,%2)    (%1 &= ~(1<<(%2&31)))
#define get_flood(%1,%2)    (%1 & (1<<(%2&31)))

#if MODE & (1<<0) || MODE & (1<<1)
new amx_password_field_string[30]
#endif
#if MODE & (1<<0)
new g_user_privileges[33]
enum _:database_items
{
	auth[50],
	password[50],
	accessflags,
	flags
}
new vips_database[database_items]
new Array:database_holder
#endif
#if MODE & (1<<1)
const ZV_PLUGIN_HANDLED = 97
enum _:items
{
	i_name[31],
	i_description[31],
	i_cost,
	i_team
}
// new g_nonvip_tease
// new g_menu_close
// new extra_items[items]
// new Array:items_database
// new g_registered_items_count
// new g_forward_return
// new g_extra_item_selected
// new g_team[33]
#endif
static const CONTACT[] = ""
new  g_infecthealth, g_show_vips, g_fall_damage
new maxplayers, g_msgSayText
new g_PlayerGlow[33]
new Bought[33]

native zp_is_apocalypse()

public plugin_init() {
	
	register_plugin("ZM VIP", VERSION, "aaarnas")
	RegisterHam(Ham_Killed, "player", "fw_PlayerKilled_Post", 1)
	RegisterHam(Ham_TakeDamage, "player", "fw_TakeDamage")
	register_event("ResetHUD", "HUDReset", "be")
	register_event("HLTV", "chache_cvars", "a", "1=0", "2=0")
	maxplayers = get_maxplayers()
	g_msgSayText = get_user_msgid("SayText")
		
	g_infecthealth = register_cvar("zp_vip_infecthealth", "300")
	g_show_vips = register_cvar("zp_vip_show", "1")
	register_cvar("amx_contactinfo", CONTACT, FCVAR_SERVER)
	register_cvar("zp_vip_version", VERSION, FCVAR_SERVER|FCVAR_SPONLY)
	set_cvar_string("zp_vip_version", VERSION)
		
#if MODE & (1<<0) || MODE & (1<<1)
	get_cvar_string("amx_password_field", amx_password_field_string, charsmax(amx_password_field_string))
	register_dictionary("zm_vip.txt")
#endif
#if MODE & (1<<0)
	register_concmd("amx_reloadvips", "reload_vips", ADMIN_CFG)
	register_concmd("zp_vip_add", "add_vip", ADMIN_RCON,"<authid> [name] [day] [month] [year]")
	register_concmd("zp_vip_remove", "remove_vip", ADMIN_RCON,"<authid>")
	register_concmd("zp_vip_check", "check_vip", ADMIN_RCON,"<authid>")
	register_concmd("zp_vip_dump", "dump_vip",ADMIN_RCON);
//	check_date();
	reload_vips(0,0,0)
#endif
#if MODE & (1<<1)
	//register_clcmd("say /vm", "menu_open")
	register_clcmd("say /glow", "GlowMenu")
	register_clcmd("say /myvip", "VIPData")
	register_clcmd("amx_glowmenu", "GlowMenu")
	register_clcmd("say /vipsub", "ExpireDate")
	// g_nonvip_tease = register_cvar("zp_vip_nonvip_tease", "1")
	// g_menu_close = register_cvar("zp_vip_menu_close", "1")
	
	g_fall_damage = register_cvar("zp_vip_no_fall_damage", "1") 
	new temp[31]
	formatex(temp, 30, "%L", LANG_SERVER, "VIP_EXTRA_NAME")
	// g_extra_item_selected = CreateMultiForward("zv_extra_item_selected", ET_CONTINUE, FP_CELL, FP_CELL)
#endif
	register_clcmd("say /vips", "print_adminlist")
	register_clcmd("say /vip", "ShowMotd")
}

// new Arma,NC,Dragon,Nemesis,Survivor,Knifer,Plasma,/*Sniper,*/Predator

// new Tag,Wars,Potato,Cannibals,Nightmare,Alien,Race,SVN//,Santa,Presents,GG
	new Cannibals
public plugin_cfg()
{
	// SVN = zp_gamemodes_get_id("Snipers Vs Nemesis")
	// Arma = zp_gamemodes_get_id("Armageddon Mode")
	// NC = zp_gamemodes_get_id("Nightcrawler Mode")	
	// Dragon = zp_gamemodes_get_id("Dragon Mode")		
	// Knifer = zp_gamemodes_get_id("Knifer Mode")	
	// Plasma  = zp_gamemodes_get_id("Plasma Mode")	
	// //Sniper = zp_gamemodes_get_id("Sniper Mode")
	// Nemesis= zp_gamemodes_get_id("Nemesis Mode")
	// Predator= zp_gamemodes_get_id("Predators Mode")
	// Survivor = zp_gamemodes_get_id("Survivor Mode")
	// Tag = zp_gamemodes_get_id("Zombie Tag Mode");
	// Wars = zp_gamemodes_get_id("Infection Wars Mode");
	// Potato = zp_gamemodes_get_id("Hot Potato Mode");
	Cannibals = zp_gamemodes_get_id("Cannibals Mode")
	// Nightmare = zp_gamemodes_get_id("Nightmare Mode")
	// Alien = zp_gamemodes_get_id("Alien Mode")
	// Race = zp_gamemodes_get_id("Nemesis Race Mode")
	// GG = zp_gamemodes_get_id("Gun Game Mode")
	// Santa = zp_gamemodes_get_id("Santa Mode")
	// Presents = zp_gamemodes_get_id("Presents Event!")
	
	new directory[31]
	get_configsdir(directory, 30)
	server_cmd("exec %s/zm_vip.cfg", directory)
}
/*
bool:is_special_mode()
{
	new cm = zp_gamemodes_get_current()
	if(cm==SVN||cm==Potato)//||cm==Santa||cm==Presents||cm==GG)
		return true;
	if(cm==Wars||cm==Tag||cm==Cannibals||cm==Nightmare||cm==Alien||cm==Race||cm==Arma||cm==Survivor||cm==Nemesis||cm==Predator||cm==NC||cm==Dragon||cm==Knifer||cm==Plasma)
		return true;
	
	return false;
}*/
new Used[33]

public chache_cvars() 
{
	for(new i=1;i<33;i++)
	{
		Used[i]=false;
		Bought[i]=0;
	}
	check_date();
}
#if MODE & (1<<1) || MODE & (1<<0)
public plugin_natives() {
	//register_native("zv_menu_open", "menu_open", 1)
	// register_native("zv_get_bought", "native_get_bought",1)
#if MODE & (1<<1)
	// register_native("zv_register_extra_item", "native_zv_register_extra_item", 1)
#endif
#if MODE & (1<<0)
	register_native("zv_get_user_flags", "native_zv_get_user_flags", 1)
	register_native("zv_set_user_flags", "native_zv_set_user_flags", 1)
#endif	
	register_native("zv_glow_menu_show", "GlowMenu",1)
	register_native("zv_information_show","ShowMotd",1)
}
#endif
public fw_PlayerKilled_Post(victim, attacker) {
#if MODE & (1<<0)
	if(1 <= attacker <= maxplayers && g_user_privileges[attacker] & FLAG_A) {
#else
	if(1 <= attacker <= maxplayers && get_user_flags(attacker) & VIPACCES) {
#endif	
		if(zp_gamemodes_get_current()!=Cannibals&&is_user_alive(attacker) && zp_get_user_zombie(attacker) && !is_zombie_boss(attacker)) set_user_health(attacker, (get_user_health(attacker) + get_pcvar_num(g_infecthealth)))
	}
}
public native_zv_set_user_flags(id,numb)
	g_user_privileges[id] = numb
public fw_TakeDamage(victim, inflictor, attacker, Float:damage, damage_type) {
	
	if(victim == attacker)
		return HAM_IGNORED
		
	if(damage_type & DMG_HEGRENADE)
		return HAM_IGNORED
	
#if MODE & (1<<0)
	if(g_user_privileges[victim] & FLAG_A) {
#else
	if(get_user_flags(victim) & VIPACCES) {
#endif
		if(damage_type & DMG_FALL && get_pcvar_num(g_fall_damage))
			return HAM_SUPERCEDE;
	}
	return HAM_IGNORED;
}

public zp_user_infected_post(id, infector, nemesis) {
	
	if(is_zombie_boss(id))
		return;
		
	setVip()
	
	if((g_user_privileges[id]&FLAG_A))
	{
		/*switch(g_PlayerGlow[id])
		{
			case 0:		
				set_user_rendering(id);
			case 1:		
				set_user_rendering(id, kRenderFxGlowShell, 255, 0, 0, kRenderNormal, 28)	
			case 2:		
				set_user_rendering(id, kRenderFxGlowShell, 0, 255, 0, kRenderNormal, 28)
			case 3:		
				set_user_rendering(id, kRenderFxGlowShell, 0, 0, 255, kRenderNormal, 28)
			case 4:		
				set_user_rendering(id, kRenderFxGlowShell, 255, 255, 0, kRenderNormal, 28)
			case 5:		
				set_user_rendering(id, kRenderFxGlowShell, 0, 255, 255, kRenderNormal, 28)
			case 6:		
				set_user_rendering(id, kRenderFxGlowShell, 255, 0, 255, kRenderNormal, 28)
			case 7:		
				set_user_rendering(id, kRenderFxGlowShell, 255, 128, 0, kRenderNormal, 28)
			case 8:		
				set_user_rendering(id, kRenderFxGlowShell, 192, 255, 0, kRenderNormal, 28)
			case 9:
				set_user_rendering(id, kRenderFxGlowShell, 255, 192, 192, kRenderNormal, 28)
			case 10:
				set_user_rendering(id, kRenderFxGlowShell, 255, 255, 255, kRenderNormal, 28)
		}*/
		set_user_health(id, get_user_health(id) + get_pcvar_num(g_infecthealth))
	}
	
	if(!is_user_connected(infector)||infector==id) return;
	
#if MODE & (1<<0)
	if(g_user_privileges[infector] & FLAG_A) {
#else
	if(get_user_flags(infector) & VIPACCES) {
#endif

		set_user_health(infector, (get_user_health(infector) + 500))
	}	
	
}

public client_connect(id)
	set_flags(id)
/*
public menu_open(id) {
	if(!(g_user_privileges[id] & FLAG_E))
	{
		client_printcolor(id, "/g%s /y%L", CHAT_PREFIX, id, "NOT_A_VIP")
		return PLUGIN_HANDLED;
	}	
	
	if(zp_gamemodes_get_current()==ZP_NO_GAME_MODE)
	{
		client_print(id, print_center, "You cannot use it before the mode starts");
		return ZP_PLUGIN_HANDLED
	}

	if(is_special_mode())
	{
		client_print(id, print_center, "You cannot use it in this special mode");
		return ZP_PLUGIN_HANDLED
	}
	
	if(!is_user_alive(id))
	{
		client_print(id, print_center, "You must be alive to use this");
		return ZP_PLUGIN_HANDLED
	}
	if(cant_buy(id))
	{
		client_print(id, print_center, "VIP Items not avaialble for you class");
		return ZP_PLUGIN_HANDLED
	}
	if(Used[id])
	{
		client_print(id, print_center, "You can use it again in the next round");
		return ZP_PLUGIN_HANDLED
	}

	vip_menu(id)

	return ZP_PLUGIN_HANDLED
}
	
public vip_menu(id)
{
	if(g_registered_items_count == 0) {
		client_printcolor(id, "/g%s /y%L", CHAT_PREFIX, id, "OFF")
		return;
	}
	new holder[150], menu
	formatex(holder, charsmax(holder), "\r%L", id, "MENU_TOP")
	menu = menu_create(holder, "vip_menu_handler")
	new i, team_check, num[3], ammo_packs, check
	check = 0
	ammo_packs = zp_get_user_ammo_packs(id)
	
	switch(zp_get_user_zombie(id)) {
		
		case 0: {
			if(zp_get_user_survivor(id)) team_check = ZP_TEAM_HUMAN
			else team_check = ZP_TEAM_HUMAN
		}
		case 1: {
			if(zp_get_user_nemesis(id)) team_check = ZP_TEAM_ZOMBIE
			else team_check = ZP_TEAM_ZOMBIE
		}
	}
	
	if(zp_get_user_zombie(id) && !zp_get_user_nemesis(id)) team_check |= FLAG_A
	else if(!zp_get_user_zombie(id)) team_check |= FLAG_B
	else if(zp_get_user_nemesis(id)) team_check |= FLAG_C
	else if(zp_get_user_survivor(id)) team_check |= FLAG_D
	g_team[id] = team_check
	for(i=0; i < g_registered_items_count; i++) {
		ArrayGetArray(items_database, i, extra_items)
		if(extra_items[i_team] == 0 || g_team[id] & extra_items[i_team]) {
			new message[32]
			
			if(!extra_items[i_cost]||(zp_is_apocalypse()&&(g_team[id]&FLAG_B)))
			formatex(message, charsmax(message),"\r[FREE]")
			else
			if(ammo_packs<extra_items[i_cost])
			{
				formatex(message,charsmax(message),"\d[%d Ammo Packs]",extra_items[i_cost])
			}
			else
			{
				formatex(message,charsmax(message),"\r[%d Ammo Packs]",extra_items[i_cost])
			}
			formatex(holder, charsmax(holder), "%s %s", extra_items[i_name], message)
			
			//formatex(holder, charsmax(holder), "%s %s", extra_items[i_name],  ammo_packs < extra_items[i_cost] ? "\d" : "\r", extra_items[i_cost]
			formatex(num, 2, "%d", i)
			menu_additem(menu, holder, num, 0)
			check++
		}
	}
	if(check == 0) {
		client_printcolor(id, "/g%s /y%L", CHAT_PREFIX, id, "NO_ITEMS")
		return;
	}
	menu_setprop(menu, MPROP_EXIT, MEXIT_ALL)
	formatex(holder, charsmax(holder), "%L", id, "NEXT")
	menu_setprop(menu, MPROP_NEXTNAME, holder)
	formatex(holder, charsmax(holder), "%L", id, "BACK")
	menu_setprop(menu, MPROP_BACKNAME, holder)
	formatex(holder, charsmax(holder), "%L", id, "EXIT")
	menu_setprop(menu, MPROP_EXITNAME, holder)
	menu_display(id, menu, 0)
}
 
public vip_menu_handler(id, menu, item)
{
	if( item == MENU_EXIT )
	{
		menu_destroy(menu)
		return PLUGIN_HANDLED
	}
	
#if MODE & (1<<0)
	if(get_pcvar_num(g_nonvip_tease) && !(g_user_privileges[id] & FLAG_A)) {
		client_printcolor(id, "/g%s /y%L", CHAT_PREFIX, id, "NOT_A_VIP")
		menu_destroy(menu)
		return PLUGIN_HANDLED;
	}
#else
	if(get_pcvar_num(g_nonvip_tease) && !(get_user_flags(id) & VIPACCES)) {
		client_printcolor(id, "/g%s /y%L", CHAT_PREFIX, id, "NOT_A_VIP")
		menu_destroy(menu)
		return PLUGIN_HANDLED;
	}
#endif
	new team_check
	switch(zp_get_user_zombie(id)) {
		
		case 0: {
			if(zp_get_user_survivor(id)) team_check = ZP_TEAM_HUMAN
			else team_check = ZP_TEAM_HUMAN
		}
		case 1: {
			if(zp_get_user_nemesis(id)) team_check = ZP_TEAM_ZOMBIE
			else team_check = ZP_TEAM_ZOMBIE
		}
	}
	
	if(g_team[id] != team_check) {
		
		menu_destroy(menu)
		vip_menu(id)
		return PLUGIN_HANDLED;
	}
	
	new data[6], iName[64], item_id, ammo_packs
	new aaccess, callback
	menu_item_getinfo(menu, item, aaccess, data,5, iName, 63, callback)
	item_id = str_to_num(data)
	ammo_packs = zp_get_user_ammo_packs(id)
	ArrayGetArray(items_database, item_id, extra_items)
	if(zp_is_apocalypse()){}
	else if(ammo_packs >= extra_items[i_cost])
	{
		Bought[id]+=extra_items[i_cost]
		zp_set_user_ammo_packs(id, ammo_packs - extra_items[i_cost])
	} 
	else {
		client_printcolor(id, "/g%s %L", CHAT_PREFIX, id, "MISSING_AMMO", extra_items[i_cost]-ammo_packs)
		if(g_menu_close) menu_destroy(menu)
		else vip_menu(id)
		return PLUGIN_HANDLED
	}
	item_id++
	ExecuteForward(g_extra_item_selected, g_forward_return, id, item_id)
	Used[id]=true;
	if (g_forward_return >= ZV_PLUGIN_HANDLED)
	{
		Used[id]=false;
		zp_set_user_ammo_packs(id, ammo_packs)
	}
	
	if(!g_menu_close) vip_menu(id)
	
	menu_destroy(menu)
	return PLUGIN_HANDLED
}*/

public HUDReset()
	setVip()
	
public setVip()
{
	new players[32], pNum
	get_players(players, pNum, "a")

	for (new i = 0; i < pNum; i++)
	{
		new id = players[i]
#if MODE & (1<<0)	
		if (g_user_privileges[id] & FLAG_D)
#else
		if (get_user_flags(id) & VIPACCES)
#endif
		{
			message_begin(MSG_ALL, get_user_msgid("ScoreAttrib"))
			write_byte(id)
			write_byte(4)
			message_end()
		}
	}
	return PLUGIN_HANDLED
}

public print_adminlist(user) 
{
	new adminnames[33][32]
	new message[256]
	new contactinfo[256], contact[112]
	new id, count, x, len
	
	for(id = 1 ; id <= maxplayers ; id++)
		if(is_user_connected(id))
#if MODE & (1<<0)
			if(g_user_privileges[id] & FLAG_A)
#else
			if(get_user_flags(id) & VIPACCES)
#endif
				get_user_name(id, adminnames[count++], 31)

	len = format(message, 255, "%L ", id, "VIP_STATUS")
	if(count > 0) {
		for(x = 0 ; x < count ; x++) {
			len += format(message[len], 255-len, "/t%s/y%s ", adminnames[x], x < (count-1) ? ", ":"")
			if(len > 96 ) {
				client_printcolor(user, "/t%s", message)
				len = format(message, 255, "")
			}
		}
		client_printcolor(user, "/g%s", message)
	}
	else {
		len += format(message[len], 255-len, "%L ", id, "VIP_STATUS_N")
		client_printcolor(user, "/g%s", message)
	}
	
	get_cvar_string("amx_contactinfo", contact, 63)
	if(contact[0])  {
		format(contactinfo, 111, "%L ", id, "VIP_STATUS_CON", contact)
		client_printcolor(user, "/g%s", contactinfo)
	}
	
}

public ShowMotd(id)
	show_motd(id, "vip.txt")

public remove_vip(id,level,cid)
{
	if(!cmd_access(id,level,cid,2))
		return PLUGIN_HANDLED;
	
	new arg1[32]
	read_argv(1, arg1, charsmax(arg1))
	if(!equal(arg1,"HLTV")&&!equal(arg1,"STEAM_ID_LAN"))
	{
		if((contain(arg1,"STEAM_")==-1)&&(contain(arg1,"VALVE_")==-1))
		{
			if(id) console_print(id, "Input a valid AuthID!")
			else server_print("Input a valid AuthID!")
			return PLUGIN_HANDLED;
		}
		if(arg1[7]!=':'||arg1[9]!=':'||!arg1[10])
		{
			if(id) console_print(id, "Input a valid AuthID!")
			else server_print("Input a valid AuthID!")
			return PLUGIN_HANDLED;
		}
	}
	
	new configdir[200]
	get_configsdir(configdir,199)
	new configfile1[200]
	format(configfile1,199,"%s/vips.ini",configdir)
	
	new text[512], len
	new pnum = file_size(configfile1,1)
	for(new i = 1; i < pnum; i++)
	{
		read_file(configfile1, i, text, 511, len)
		if ( contain(text, arg1) != -1 ) 
		{
			DeleteLine(configfile1, i)
			if(id) console_print(id, "Deleted %s from vips.ini!",arg1)
			else server_print("Deleted %s from vips.ini",arg1)
			reload_vips(0,0,0);
			return PLUGIN_HANDLED;
		}
	}
	if(id) console_print(id, "No match found!")
		else server_print("No match found!")
	return PLUGIN_HANDLED
}


public dump_vip(id,level,cid)
{
	if(!cmd_access(id,level,cid,1))
		return PLUGIN_HANDLED;
		
	new configdir[200]
	get_configsdir(configdir,199)
	new configfile1[200]
	format(configfile1,199,"%s/vips.ini",configdir)
	
	new text[512], len
	new pnum = file_size(configfile1,1)
	if(file_size(configfile1,2))
	{
		pnum--;
	}
	for(new i = 1; i < pnum; i++)
	{
		read_file(configfile1, i, text, 511, len)			
		if(id) console_print(id,text)
		else server_print(text)
	}
	return PLUGIN_HANDLED
}

public check_vip(id,level,cid)
{
	if(!cmd_access(id,level,cid,2))
		return PLUGIN_HANDLED;
	
	new arg1[32]
	read_argv(1, arg1, charsmax(arg1))
	if(!equal(arg1,"HLTV")&&!equal(arg1,"STEAM_ID_LAN"))
	{
		if((contain(arg1,"STEAM_")==-1)&&(contain(arg1,"VALVE_")==-1))
		{
			if(id) console_print(id, "Input a valid AuthID!")
			else server_print("Input a valid AuthID!")
			return PLUGIN_HANDLED;
		}
		if(arg1[7]!=':'||arg1[9]!=':'||!arg1[10])
		{
			if(id) console_print(id, "Input a valid AuthID!")
			else server_print("Input a valid AuthID!")
			return PLUGIN_HANDLED;
		}
	}
	
	new configdir[200]
	get_configsdir(configdir,199)
	new configfile1[200]
	format(configfile1,199,"%s/vips.ini",configdir)
	
	new text[512], len
	new pnum = file_size(configfile1,1)
	for(new i = 1; i < pnum; i++)
	{
		read_file(configfile1, i, text, 511, len)
		if ( contain(text, arg1) != -1 ) 
		{
			formatex(text, charsmax(text),"%s^nRead from vips.ini",text);			
			if(id) console_print(id,text)
			else server_print(text)
			return PLUGIN_HANDLED;
		}
	}
	if(id) console_print(id, "No match found!")
	else server_print("No match found!")
	return PLUGIN_HANDLED
}
public add_vip(id,level,cid)
{
	if(!cmd_access(id,level,cid,2))
		return PLUGIN_HANDLED;
	
	new arg1[32]
	read_argv(1, arg1, charsmax(arg1))
	if(!equal(arg1,"HLTV")&&!equal(arg1,"STEAM_ID_LAN"))
	{
		if((contain(arg1,"STEAM_")==-1)&&(contain(arg1,"VALVE_")==-1))
		{
			if(id) console_print(id, "Input a valid AuthID!")
			else server_print("Input a valid AuthID!")
			return PLUGIN_HANDLED;
		}
		if(arg1[7]!=':'||arg1[9]!=':'||!arg1[10])
		{
			if(id) console_print(id, "Input a valid AuthID!")
			else server_print("Input a valid AuthID!")
			return PLUGIN_HANDLED;
		}
	}
	new exists;
	///////////////////////////////////////////
	////////////////Reload VIPS////////////////
	///////////////////////////////////////////
	
	new configsDir[64]
	get_configsdir(configsDir, 63)
	format(configsDir, 63, "%s/vips.ini", configsDir)	
	new File=fopen(configsDir,"r+");	
	if (File)
	{
		static Text[512], AuthData[50]
		while (!feof(File))
		{
			fgets(File,Text,sizeof(Text)-1);
			
			trim(Text);
			
			// comment
			if (Text[0]==';') 
			{
				continue;
			}
			
			AuthData[0]=0;
			
			// not enough parameters
			if (parse(Text,AuthData,sizeof(AuthData)-1)<0)
			{
				continue;
			}
			if(equal(AuthData,arg1))
			{
				exists=true;
				break;
			}
		}
		
	}
	else log_amx("Error: vips.ini file doesn't exist")
	
	if(exists)
	{
		if(id) console_print(id, "This player is already VIP!")
		else server_print( "This player is already VIP!")			
		fclose(File);
		return PLUGIN_HANDLED;
	}
	
	new vipstring[256]
	if(file_size(configsDir,2))
	formatex(vipstring,charsmax(vipstring),"^"%s^" ^"^" ^"ae^" ^"ce^";",arg1);
	else
	formatex(vipstring,charsmax(vipstring),"^n^"%s^" ^"^" ^"ae^" ^"ce^";",arg1);
	new arg2[64]
	read_argv(2, arg2,charsmax(arg2))
	formatex(vipstring,charsmax(vipstring),"%s %s",vipstring,arg2);
	
	client_print(id, print_console,"%d",read_argc());
	if(read_argc()>3)
	{
		new argd[3],argm[3],argy[5]
		new d,m,y;
		read_argv(3,argd,charsmax(argd))
		d = str_to_num(argd)
		read_argv(4,argm,charsmax(argm))
		m = str_to_num(argm)
		read_argv(5,argy,charsmax(argy))
		y= str_to_num(argy)
		
		if(!isValidDate(d,m,y,id))
		{			
			fclose(File);
			return PLUGIN_HANDLED;
		}		
		formatex(vipstring,charsmax(vipstring),"%s m%dd%dy%d",vipstring,m, d, y)
	}	
	fputs(File, vipstring);		
	fclose(File);
	if(id) console_print(id, "Added to vips.ini: %s",vipstring)
	else server_print( "Added to vips.ini: %s",vipstring)
	reload_vips(0,0,0);
	return PLUGIN_HANDLED;
}

// Returns true if
// given year is valid.
bool:isLeap(year)
{
	// Return true if year
	// is a multiple pf 4 and
	// not multiple of 100.
	// OR year is multiple of 400.
	return (((year % 4 == 0) &&
	(year % 100 != 0)) ||
	(year % 400 == 0));
}

// Returns true if given
// year is valid or not.
bool:isValidDate(d, m, y,id)
{
	
	if (m < 1 || m > 12)
	{
		if(id)	console_print(id, "Input a month between 1 and 12!");
		else	server_print("Input a month between 1 and 12!")
		return false;
	}
	if (d < 1 || d > 31)
	{
		if(id)	console_print(id, "Input a day between 1 and 31!");
		else	server_print("Input a month between 1 and 31!")
		return false;
	}
	
	// Handle February month
	// with leap year
	if (m == 2)
	{
		if (isLeap(y))
		{
			if(d<=29)
			{
				
				return true;				
			}
			
			if(id)	console_print(id, "Input a day between 1 and 29 (Leap year)!");
			else	server_print("Input a day between 1 and 29 (Leap year)!");
			
			return false
		}
		else
		{
			if(d <= 28)
			{
				return true;
			}
			if(id)	console_print(id, "Input a day between 1 and 28 (February)!");
			else	server_print("Input a day between 1 and 28 (February)!");			
			return false;
		}
	}
	
	// Months of April, June,
	// Sept and Nov must have
	// number of days less than
	// or equal to 30.
	if (m == 4 || m == 6 ||
	m == 9 || m == 11)
	{		
		if(d <= 30)
		{
			return true;
		}
		if(id)	console_print(id, "Input a day between 1 and 30!");
		else	server_print("Input a day between 1 and 30!");
		return false;
	}
	
	return true;
}
public reload_vips(id,level,cid) {	
	
	if(id)
	{
		if(!cmd_access(id, level,cid, 0))
			return PLUGIN_HANDLED;
	}
		
	if(database_holder) ArrayDestroy(database_holder)
	database_holder = ArrayCreate(database_items)
	new configsDir[64]
	get_configsdir(configsDir, 63)
	format(configsDir, 63, "%s/vips.ini", configsDir)	
	new File=fopen(configsDir,"r");	
	if (File)
	{
		static Text[512], Flags[32], AuthData[50], Privileges_Flags[32], Password[50]
		while (!feof(File))
		{
			fgets(File,Text,sizeof(Text)-1);
			
			trim(Text);
			
			// comment
			if (Text[0]==';') 
			{
				continue;
			}
			
			Flags[0]=0;
			AuthData[0]=0;
			Privileges_Flags[0]=0;
			Password[0]=0;
			
			// not enough parameters
			if (parse(Text,AuthData,sizeof(AuthData)-1,Password,sizeof(Password)-1,Privileges_Flags,sizeof(Privileges_Flags)-1,Flags,sizeof(Flags)-1) < 2)
			{
				continue;
			}

			vips_database[auth] = AuthData
			vips_database[password] = Password
			vips_database[accessflags] = read_flags(Privileges_Flags)
			vips_database[flags] = read_flags(Flags)
			ArrayPushArray(database_holder, vips_database)
		}
		
		fclose(File);
	}
	else log_amx("Error: vips.ini file doesn't exist")
	
	for(new i=1;i<33;i++)
	{
		if(is_user_connected(i))
			set_flags(i);
	}
	return PLUGIN_HANDLED;
}
public check_date()
{
	new holder[20], tholder[8],szData[64],szValue[32] 
	new y, m ,d, h
	date(y, m, d)
	time(h)
	format(holder, charsmax(holder), "m%dd%dy%d", m, d, y)
	formatex(tholder,charsmax(tholder),"h%d",h-1)
	new configdir[200]
	get_configsdir(configdir,199)

	new configfile1[200]

	format(configfile1,199,"%s/vips.ini",configdir)
	
	new text[512], len
	new pnum = file_size(configfile1,1)
	for(new i = 1; i < pnum; i++)
	{
		read_file(configfile1, i, text, 511, len)
		strtok2(text,szData,24,szValue,24,'=',LTRIM_LEFT)
//		log_to_file("vips_db.log", "%s | %s | %s",text, szValue, tholder)
		if ( contain(text, holder) != -1 ) 
		{
			if( equal(szValue, tholder))
			{
				DeleteLine(configfile1, i)
				log_to_file("vips_expired.log", "%s Expired",text)
			}
		}
	}
	return PLUGIN_HANDLED
}
public ExpireDate(id)
{
	new holder[32]
	new configdir[200],configfile1[200]
	get_configsdir(configdir,199)
	format(configfile1,199,"%s/vips.ini",configdir)
	get_user_authid(id, holder,charsmax(holder))
	new text[512], len, iStmFormat[40],iFinalTxt[180]
	new pnum = file_size(configfile1,1)
	for(new i = 1; i < pnum; i++)
	{
		read_file(configfile1, i, text, 511, len)
		if ( contain(text, holder) != -1 ) 
		{
			formatex(iStmFormat,charsmax(iStmFormat),"^"%s^"",holder)
			replace_all(text,charsmax(text), iStmFormat,"")
			replace_all(text,charsmax(text),"^"^"","")
			replace_all(text,charsmax(text),"^"bd^"","")
			replace_all(text,charsmax(text),"^"ade^"","")
			replace_all(text,charsmax(text),"^"ce^"","")
			replace_all(text,charsmax(text),";","^1| ")			
			formatex(iFinalTxt,charsmax(iFinalTxt),"[GC]^3 ID:^4 %s ^4 %s", holder, text)
			ColorChat(id,GREEN,"%s",iFinalTxt)
			break;
		}
	}
	return PLUGIN_HANDLED
}

DeleteLine( const szFilename[ ], const iLine )
{
	new iFile = fopen( szFilename, "rt" );
	if( !iFile )
	{
		return;
	}
	static const szTempFilename[ ] = "delete_line.txt";
	new iTempFile = fopen( szTempFilename, "wt" );
    
	new szData[ 256 ], iLineCount, bool:bReplaced = false;
	while( !feof( iFile ) )
	{
		fgets( iFile, szData, 255 );
        
		if( iLineCount++ == iLine )
		{
			bReplaced = true;
		}
		else
		{
			fputs( iTempFile, szData );
		}
	}
    
	fclose( iFile );
	fclose( iTempFile );
    
	if( bReplaced )
	{
		delete_file( szFilename );
        
		while( !rename_file( szTempFilename, szFilename, 1 ) ) { }
	}
	else
	{
		delete_file( szTempFilename );
	}
}

stock get_date(days, string[], chars) {
	
	new y, m, d
	date(y, m ,d)
	
	d+=days
	
	new go = true
	while(go) {
		switch(m) {
			case 1,3, 5, 7, 8, 10: {
				if(d>31) { d=d-31; m++; }
				else go = false
			}
			case 2: {
				if(d>28) { d=d-28; m++; }
				else go = false
			}
			case 4, 6, 9, 11: {
				if(d>30) { d=d-30; m++; }
				else go = false
			}
			case 12: {
				if(d>31) { d=d-31; y++; m=1; }
				else go = false
			}
		}
	}
	formatex(string, chars, "m%dd%dy%d", m, d ,y)
}

stock client_printcolor(id, const message[], any:...)
{
	static buffer[512], argscount
	argscount = numargs()
	
	if (!id) {
		
		static players[32], num, player, i, i2
		get_players(players, num , "ch")
			
		for (i = 0; i < num; i++) {
			
			player = players[i]
			
			static changed[5], changedcount
			changedcount = 0
			
			for (i2 = 2; i2 < argscount; i2++)
			{
				if (getarg(i2) == LANG_PLAYER)
				{
					setarg(i2, 0, player)
					changed[changedcount] = i2
					changedcount++
				}
			}
			
			vformat(buffer, charsmax(buffer), message, 3)
			
			replace_all(buffer, charsmax(buffer), "/g", "^4")
			replace_all(buffer, charsmax(buffer), "/y", "^1")
			replace_all(buffer, charsmax(buffer), "/t", "^3")
		
			message_begin(MSG_ONE_UNRELIABLE, g_msgSayText, _, player)
			write_byte(player)
			write_string(buffer)
			message_end()
			
			for (i2 = 0; i2 < changedcount; i2++)
				setarg(changed[i2], 0, LANG_PLAYER)
		}
	}
	else {
		
		vformat(buffer, charsmax(buffer), message, 3)
		
		replace_all(buffer, charsmax(buffer), "/g", "^4")
		replace_all(buffer, charsmax(buffer), "/y", "^1")
		replace_all(buffer, charsmax(buffer), "/t", "^3")
		
		message_begin(MSG_ONE_UNRELIABLE, g_msgSayText, _, id)
		write_byte(id)
		write_string(buffer)
		message_end()
	}
}

stock fm_find_ent_by_owner(entity, const classname[], owner)
{
	while ((entity = engfunc(EngFunc_FindEntityByString, entity, "classname", classname)) && pev(entity, pev_owner) != owner) {}
	
	return entity;
}

stock fm_set_weapon_ammo(entity, amount)
{
	set_pdata_int(entity, OFFSET_CLIPAMMO, amount, OFFSET_LINUX_WEAPONS);
}
#if MODE & (1<<0)
public set_flags(id) {
	
	static authid[31], ip[31], name[51], index, client_password[30], size, log_flags[11]
	get_user_authid(id, authid, 30)
	get_user_ip(id, ip, 30, 1)
	get_user_name(id, name, 50)
	get_user_info(id, amx_password_field_string, client_password, charsmax(client_password))
	
	g_user_privileges[id] = 0
	size = ArraySize(database_holder)
	for(index=0; index < size ; index++) {
		ArrayGetArray(database_holder, index, vips_database)
		if(vips_database[flags] & FLAG_D) {
			if(equal(ip, vips_database[auth])) {
				if(!(vips_database[flags] & FLAG_E)) {
					if(equal(client_password, vips_database[password]))
						g_user_privileges[id] = vips_database[accessflags]
					else if(vips_database[flags] & FLAG_A) {
						server_cmd("kick #%d ^"%L^"", get_user_userid(id), id, "INV_PAS")
						break
					}
				}
				else g_user_privileges[id] = vips_database[accessflags]
				get_flags(vips_database[accessflags], log_flags, 10)
				log_amx("%L",LANG_PLAYER, "AUTHORISED", name, authid, ip, log_flags)
				break
			}
		}
		else if(vips_database[flags] & FLAG_C) {
			if(equal(authid, vips_database[auth])) {
				if(!(vips_database[flags] & FLAG_E)) {
					if(equal(client_password, vips_database[password]))
						g_user_privileges[id] = vips_database[accessflags]
					else if(vips_database[flags] & FLAG_A) {
						server_cmd("kick #%d ^"%L^"", get_user_userid(id), id, "INV_PAS")
						break
					}
				}
				else g_user_privileges[id] = vips_database[accessflags]
				get_flags(vips_database[accessflags], log_flags, 10)
				log_amx("%L",LANG_PLAYER, "AUTHORISED", name, authid, ip, log_flags)
				break
			}
		}
		else {
			if(vips_database[flags] & FLAG_K) {
				if((vips_database[flags] & FLAG_B && contain(name, vips_database[auth]) != -1) || equal(name, vips_database[auth])) {
					if(!(vips_database[flags] & FLAG_E)) {
						if(equal(client_password, vips_database[password]))
							g_user_privileges[id] = vips_database[accessflags]
						else if(vips_database[flags] & FLAG_A) {
							server_cmd("kick #%d ^"%L^"", get_user_userid(id), id, "INV_PAS")
							break
						}
					}
					else g_user_privileges[id] = vips_database[accessflags]
					get_flags(vips_database[accessflags], log_flags, 10)
					log_amx("%L",LANG_PLAYER, "AUTHORISED", name, authid, ip, log_flags)
					break
				}
			}
			else {
				if((vips_database[flags] & FLAG_B && contain(name, vips_database[auth]) != -1) || equal(name, vips_database[auth])) {
					if(!(vips_database[flags] & FLAG_E)) {
						if(equal(client_password, vips_database[password]))
							g_user_privileges[id] = vips_database[accessflags]
						else if(vips_database[flags] & FLAG_A) {
							server_cmd("kick #%d ^"%L^"", get_user_userid(id), id, "INV_PAS")
							break
						}
					}
					else g_user_privileges[id] = vips_database[accessflags]
					get_flags(vips_database[accessflags], log_flags, 10)
					log_amx("%L",LANG_PLAYER, "AUTHORISED", name, authid, ip, log_flags)
					break
				}
			}
		}
	}
}
#endif
#if MODE & (1<<0) && MODE & (1<<1)
stock generate_password(id) {
	
	new password_holder[30]
	formatex(password_holder, charsmax(password_holder), "%d%d%d%d%d", random(10), random(10), random(10), random(10), random(10))
	client_cmd(id, "setinfo %s %s", amx_password_field_string, password_holder)
}
#endif

public native_get_bought(id)
{
	return Bought[id];
}

#if MODE & (1<<0)
public native_zv_get_user_flags(id)
	return g_user_privileges[id]
public VIPData(id) 
	client_printcolor(id, "/g[GC]/y Your VIP Access is %d!", g_user_privileges[id])
#endif
#if MODE & (1<<1)
/*
public native_zv_register_extra_item(const item_name[], const item_discription[], item_cost, item_team)
{
		if(!items_database) items_database = ArrayCreate(items)
		
		param_convert(1)
		param_convert(2)
		copy(extra_items[i_name], 30, item_name)
		copy(extra_items[i_description], 30, item_discription)
		extra_items[i_cost] = item_cost
		extra_items[i_team] = item_team
		ArrayPushArray(items_database, extra_items)
		g_registered_items_count++

		return g_registered_items_count
}

public plugin_end() if(items_database) ArrayDestroy(items_database)*/
#endif

public GlowMenu(id)
{		
	
	if(!(g_user_privileges[id]&FLAG_D))
	{
		client_printcolor(id, "/g%s /y%L", CHAT_PREFIX, id, "NOT_A_VIP")
		return PLUGIN_HANDLED;
	}

	if(!is_user_alive(id))
	{
		client_printcolor(id, "/g[GC]/y You must be /gAlive/y to use this!")
		return PLUGIN_HANDLED;
	}

	if(zp_core_is_zombie(id))
	{
		client_printcolor(id, "/g[GC]/y You must be a/g Human/y to use this!")
		return PLUGIN_HANDLED;
	}
		
		
	new Menu = menu_create("\r[GC] \wGlow\y Menu\w","glow_handler")
	
	menu_additem(Menu, g_PlayerGlow[id]==0?"Off \r(Selected)":"Off")
	menu_additem(Menu, g_PlayerGlow[id]==1?"Special \r(Selected)":"Special")
	menu_additem(Menu, g_PlayerGlow[id]==2?"Red \r(Selected)":"Red")
	menu_additem(Menu, g_PlayerGlow[id]==3?"Green \r(Selected)":"Green")
	menu_additem(Menu, g_PlayerGlow[id]==4?"Blue \r(Selected)":"Blue")
	menu_additem(Menu, g_PlayerGlow[id]==5?"Yellow \r(Selected)":"Yellow")
	menu_additem(Menu, g_PlayerGlow[id]==6?"Cyan \r(Selected)":"Cyan")
	menu_additem(Menu, g_PlayerGlow[id]==7?"Purple \r(Selected)":"Purple")
	menu_additem(Menu, g_PlayerGlow[id]==8?"Orange \r(Selected)":"Orange")
	menu_additem(Menu, g_PlayerGlow[id]==9?"Lime \r(Selected)":"Lime")	
	menu_additem(Menu, g_PlayerGlow[id]==10?"Pink \r(Selected)":"Pink")
	menu_additem(Menu, g_PlayerGlow[id]==11?"White \r(Selected)":"White")
	
	menu_setprop( Menu, MPROP_EXIT, MEXIT_ALL );
	menu_display( id, Menu, 0 );
	return PLUGIN_HANDLED;
}


public glow_handler(id,menu,item)
{	
	if(!is_user_alive(id))
	{
		menu_destroy(menu);
		return PLUGIN_HANDLED;	
	}
	if(zp_class_survivor_get(id) || zp_class_sniper_get(id) || zp_class_knifer_get(id) || zp_class_plasma_get(id))
	{
		ColorChat(id, GREEN,"[GC]^3You can't glow as a^4 special")
		return PLUGIN_HANDLED;
	}
	if(zp_core_is_zombie(id))
	{		
		menu_destroy(menu);
		return PLUGIN_HANDLED;
	}
	
	if(!(g_user_privileges[id]&FLAG_D))
	{
		menu_destroy(menu);
		return PLUGIN_HANDLED;	
	}
		
	if(item>-1&&item<11)
	{
		g_PlayerGlow[id]=item;
	}
		
	switch(item)
	{			
		case 0:		
		{
			zp_set_human_glow(id, false)
			set_user_rendering(id);	
		}		
		case 1:		
		{			
			zp_set_human_glow(id, true)
		}
		case 2:		
		{
			zp_set_human_glow(id, false)
			set_user_rendering(id, kRenderFxGlowShell, 255, 0, 0, kRenderNormal, 28)
		}
		case 3:		
		{
			zp_set_human_glow(id, false)
			set_user_rendering(id, kRenderFxGlowShell, 0, 255, 0, kRenderNormal, 28)
		}
		case 4:		
		{
			zp_set_human_glow(id, false)
			set_user_rendering(id, kRenderFxGlowShell, 0, 0, 255, kRenderNormal, 28)
		}
		case 5:		
		{
			zp_set_human_glow(id, false)
			set_user_rendering(id, kRenderFxGlowShell, 255, 255, 0, kRenderNormal, 28)
		}
		case 6:		
		{
			zp_set_human_glow(id, false)
			set_user_rendering(id, kRenderFxGlowShell, 0, 255, 255, kRenderNormal, 28)
		}
		case 7:	
		{	
			zp_set_human_glow(id, false)
			set_user_rendering(id, kRenderFxGlowShell, 255, 0, 255, kRenderNormal, 28)
		}
		case 8:		
		{
			zp_set_human_glow(id, false)
			set_user_rendering(id, kRenderFxGlowShell, 255, 128, 0, kRenderNormal, 28)
		}
		case 9:		
		{
			zp_set_human_glow(id, false)
			set_user_rendering(id, kRenderFxGlowShell, 192, 255, 0, kRenderNormal, 28)
		}
		case 10:
		{
			zp_set_human_glow(id, false)
			set_user_rendering(id, kRenderFxGlowShell, 255, 192, 192, kRenderNormal, 28)
		}
		case 11:
		{
			zp_set_human_glow(id, false)
			set_user_rendering(id, kRenderFxGlowShell, 255, 255, 255, kRenderNormal, 28)
		}
			
		case MENU_EXIT:
		{
			menu_destroy(menu);
			return PLUGIN_HANDLED;	
		}
	}
	client_printcolor(id, "/g[GC]/y Your /tGlow/y was /tSet!")
	menu_destroy(menu);	
	GlowMenu(id)
	return PLUGIN_HANDLED;	
}

public zp_user_humanized_post(id)
{
	if(!(g_user_privileges[id]&FLAG_D))
		return;
	if(zp_class_survivor_get(id) || zp_class_sniper_get(id) || zp_class_knifer_get(id) || zp_class_plasma_get(id))
		return;		
	switch(g_PlayerGlow[id])
	{
		case 0:		
			set_user_rendering(id);
		case 2:		
			set_user_rendering(id, kRenderFxGlowShell, 255, 0, 0, kRenderNormal, 28)	
		case 3:		
			set_user_rendering(id, kRenderFxGlowShell, 0, 255, 0, kRenderNormal, 28)
		case 4:		
			set_user_rendering(id, kRenderFxGlowShell, 0, 0, 255, kRenderNormal, 28)
		case 5:		
			set_user_rendering(id, kRenderFxGlowShell, 255, 255, 0, kRenderNormal, 28)
		case 6:		
			set_user_rendering(id, kRenderFxGlowShell, 0, 255, 255, kRenderNormal, 28)
		case 7:		
			set_user_rendering(id, kRenderFxGlowShell, 255, 0, 255, kRenderNormal, 28)
		case 8:		
			set_user_rendering(id, kRenderFxGlowShell, 255, 128, 0, kRenderNormal, 28)
		case 9:		
			set_user_rendering(id, kRenderFxGlowShell, 192, 255, 0, kRenderNormal, 28)
		case 10:
			set_user_rendering(id, kRenderFxGlowShell, 255, 192, 192, kRenderNormal, 28)
		case 11:
			set_user_rendering(id, kRenderFxGlowShell, 255, 255, 255, kRenderNormal, 28)
	}
}

is_zombie_boss(id)
{
	return (zp_class_nemesis_get(id)||zp_class_predator_get(id)||zp_class_dragon_get(id)||zp_class_nightcrawler_get(id));
}
/*
cant_buy(id)
{
		return(zp_class_nemesis_get(id)||zp_class_predator_get(id)||zp_class_dragon_get(id)||zp_class_nightcrawler_get(id)||zp_class_sniper_get(id)||zp_class_knifer_get(id)||zp_class_plasma_get(id)||zp_class_survivor_get(id))
}*/
/* AMXX-Studio Notes - DO NOT MODIFY BELOW HERE
*{\\ rtf1\\ ansi\\ deff0{\\ fonttbl{\\ f0\\ fnil Tahoma;}}\n\\ viewkind4\\ uc1\\ pard\\ lang1033\\ f0\\ fs16 \n\\ par }
*/